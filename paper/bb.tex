\documentclass{article}

\input{preamble.tex}

\begin{document}

	\section{Exact Algorithm}

	In this section we give an exact algorithm for finding an exact
	bipartitioning of a matrix, extending the branch and bound
	algorithm by Pelt \&
	Bisseling \cite{pelt-and-bisseling}. We first give a quick overview
	of their approach, though
	a better understanding can be gained by reading the
	paper itself.

	After that we give two new bounds that extend the reach of the previous
	algorithm.

	\subsection{Previous work}

	All of this subsection concerns work done in \cite{pelt-and-bisseling}.

	Recall that a branch and bound algorithm initially starts with
	(a representation of) the whole solution space, and then repeatedly
	branches on properties of the solutions until these are refined
	enough that they specify a single solution (this is a leaf in the branch
	and bound tree). When the properties are
	chosen carefully, we may cut off (`bound') large parts of the search
	tree.

	In the case of matrix bipartitioning, a first obvious choice would 
	be to branch on
	which side of the partition we put each nonzero in. For an $n \times m$
	matrix with $N$ nonzeros this results in $2^N$ leaf nodes. However,
	\todo{waarom niet?, even goed praten waarom dit een slecht idee is}.
	Instead, we can branch of the status of each of the
	rows and columns of the matrix: each of them is either entirely red,
	entirely blue, or `cut', i.e. it contains both colors. As a result, we
	only have $3^{n+m}$ leafs, which is already smaller than $2^N$ when
	$n + m < \log_3(2) N \approx 0.63N$. In fact, not all of the $3^{n+m}$
	states are even reachable: if a row and column intersect in a nonzero,
	we cannot mark one of them as \textit{red} and one of them as \textit{blue}
	(i.e. we do require assignments be consistent).

	When we traverse the branch and bound tree, at each stage we have a
	`partial assignment', where some of the rows and columns are
	\textit{red}, \textit{blue} or \textit{cut}, and some are still
	unassigned. For a given matrix $M$ and its bipartite graph representation
	$G(M) = (V, E)$ (recall \autoref{}),
	we will write $R \subseteq V$ (resp. $B, C \subseteq V$)
	for the vertices (corresponding to rows and columns) that were assigned
	\textit{red} (resp. \textit{blue}, \textit{cut}). Additionally, while
	all remaining vertices are unassigned, they may still be connected to
	vertices in $R, B$ and $C$. For example, if an unassigned column
	vertex $u$ is
	adjacent to a row vertex in $r \in R$, this means that $M_{ru}$ is nonzero.
	In particular, since row $r$ is red, we cannot make $u$ blue. So we will
	call $u$ \textit{partially red}, with the corresponding subset of $V$
	written as $P_R$ (with $P_B$ defined
	analogously). Finally, an unassigned vertex may have neighbours in both
	$R$ and $B$. While unassigned, we are basically forced to cut this vertex.
	Because of this, we assume that whenever such a vertex is created, we
	immediately cut it. So we will ignore these vertices.

	For pruning, the following two lower bounds on solution cost are used:
	\begin{enumerate}
		\item[] \textbf{Packing bound} Let $E(R)$ denote all the edges that
				are colored red by the current partial assignment (that is, all
				edges adjacent to a vertex in $R$).
				For each partially red vertex
				$p \in P_R$ (i.e. $p$ has a vertex in $R$ adjacent), let
				$$N^R(p) = \{\, e \in E \,\mid\, \text{$e$ is adjacent to $p$
				but not to $R$ or $B$}\,\}$$
				Then all edges in $N^R(p)$ are still free, but directly
				adjacent to a red edge, since $p$ is adjacent to some $r\in R$,
				so we are forced to color $\{p, r\}$ red.

				If we don't want to cut any more vertices, we have to color all
				edges in $N^R(p)$ red. But if
				$|E(R)| + \sum_{p\in P_R} |N^R(p)| > \frac{1}{2}|E|$, this will
				lead to an unbalanced partition, and we are forced to color
				some of the edges in question blue, cutting some
				of the vertices $p \in P_R$ in the process.
				Since we are looking for a lower
				bound, we can greedily take those vertices with largest
				$|N^R(p)|$ until the sum is small enough again.

				Note that we implicitly assumed all the $N^R(p)$ were disjoint,
				so we can assign their edges independently. Since
				$G(M) = (V,E)$ is bipartite, this is true if we consider each
				side of the bipartition separately (that is, the rows and the
				columns). We can then do the same
				for $P_B$, and add everything together to get the
				\textit{packing bound}.
		\item[] \textbf{Matching bound} Let's consider some $p \in P_R$ and
				$q \in P_B$ with $\{p, q\} \in E$. We note that $p$ has a red
				edge adjacent (through its adjacent vertex in $R$), and $q$ has
				a blue edge adjacent. Clearly no matter what color we give
				$\{p, q\}$, we will have to cut one of them.

				We can improve this by finding a maximal set of such edges that
				are disjoint (this is necessary, since otherwise we could
				resolve $\{p, q\}$ and $\{p, q'\}$ just by cutting $p$).
				The relevant graph is just our bipartite graph
				$G(M) = (V, E)$ restricted to
				$P_R \cup P_B \subseteq V$, keeping only edges with one
				endpoint in $P_R$ and one in $P_B$. Bipartite
				matching is a classical problem we can solve in polynomial
				time. Then the size of the maximum matching is a lower bound
				on the number of vertices that still have to be cut by any
				extension of the current partial assignment.
	\end{enumerate}

	These two bounds conflict with each other, so must take the maximum of the
	two. We add to this the total number of already cut vertices $|C|$ to
	obtain a lower bound on any extension of the current partial assignment.
	If this matches the cost of the best solution already seen (an obvious
	upper bound on the optimal solution), we can prune the current subtree.

	One issue with these two bounds is that they are in some sense `local'
	bounds. They both only consider the direct neighbourhoods of $R$ and $B$
	(through $P_R$ and $P_B$). The two bounds we give next can be seen as
	extending the above bounds to the whole graph, taking full advantages of
	its connectivity.

	\subsection{Flow Bound}

	We will begin by extending the matching bound to the whole graph. The
	matching bound considers edges that are adjacent to both red and blue
	edges (through $P_R$ and $P_B$). But there is no need to consider just
	a single edge, and this is especially obvious when we consider the graph
	formulation of the problem.

	Consider a path from $P_R$ to $P_B$ avoiding $R \cup B \cup C$, that is,
	a series of vertices $v_1, v_2, \dots, v_k$ with
	$v_i \not\in R\cup B\cup C$ for $1 \leq i\leq k$,
	and in particular $v_1 \in P_R$ and $v_k \in P_B$,
	such that $\{v_i, v_{i+1}\} \in E$ for all $1 \leq i < k$. This
	corresponds to a series of intersecting rows and columns, the first of
	which contains a red nonzero (corresponding to the edge between $v_1$ and
	its neighbour in $R$) and the last a blue nonzero.

	Clearly then any extension of the current partial assignment must cut one
	of these vertices. If $v_1$ is not cut then it must be fully red, making
	$v_2$ partially red, etc..

	\todo{Image, from slides? Maar die heeft 2 paths, dus kan later miss.beter}

	So if a single path between $P_R$ and $P_B$ implies that we have to cut at
	least one vertex, how do we extend this to multiple paths? Here we run in
	to the same issue as with the matching bound: if we have two paths that
	share a vertex, we can just cut that vertex to separate red and blue edges,
	for a cost of $1$.

	\todo{Hier is een plaatje ook wel leuk, maar niet echt nodig}

	Hence, to prove a lower bound of more than $1$ we have to require that the
	paths are disjoint. In particular, the
	strongest lower bound we can find will be the maximum number of vertex
	disjoint paths between $P_R$ and $P_B$. Note that these paths must be
	vertex disjoint in $P_R$ and $P_B$ as well, since those vertices may also
	still be cut. Alternatively, when we imagine $R$ and $B$ as a single
	vertex, we are looking for a maximum number of paths from $R$ to $B$ that
	are vertex disjoint outside of $R$ and $B$. In fact, a theorem by Menger
	shows that this is actually exactly the size of the smallest vertex cut.

	\begin{theorem}{(Menger, \cite{})}
		Let $G$ be a finite undirected graph, and let $u$ and $v$ be two
		non-adjacent vertices in $G$, then the size of the smallest vertex cut
		separating $u$ and $v$ equals the maximum number of vertex disjoint
		paths between $u$ and $v$.
	\end{theorem}

	Unfortunately, the resulting cut may be very unbalanced, so we can only
	use this as an upperbound.

	\subsubsection{Implementation notes on the Flow Bound}

	Finding a maximal set of vertex disjoint paths is a classical maximum flow
	problem, that can be solved by duplicating each vertex and connecting them
	with a capacity $1$ edge, to enforce that every vertex be used only once.
	A good description on how to do this exactly may be found in \todo{Find
		something}.

	However, while the maximum flow problem may be solved in polynomial time,
	it still requires computation over the entire graph

	\todo{For implementation notes, misschien toch uitleggen?}

	\subsection{Extended Packing Bound}

	We now consider the problem of extending the packing bound over the whole
	graph (rather than just neighbourhoods of $R$ and $B$). This idea is based
	on 
	\begin{definition}
		An internally connected
	\end{definition}

	\subsubsection{Implementation notes on the Extended Packing Bound}

	\subsection{Further implementation notes}

	In this section, in the interest of reproducibility, we make a few notes
	on relevant decisions we made regarding implementation of the branch and
	bound algorithm.

	\subsubsection{Branching strategy}
	While we already specified that we branch on marking a row or column as
	\textit{red}, \textit{blue} or \textit{cut}, the order in which we
	select the rows and columns for branching could significantly affect the
	performance of the algorithm.

	Intuitively, it makes sense to branch on rows and columns with more free
	nonzeros, since their assignment affects the balance of the bipartitioning
	the most, and their high connectivity suggests they may be useful as
	sources of paths in the Flow Bound or subgraphs in the Extended Packing
	Bound. Thus, at each step we select for branching a row or column $u$
	with a maximal
	number of unassigned nonzeros, breaking ties arbitrarily. Additionally,
	since the goal is to cut as few rows and columns as possible, we traverse
	the `\textit{cut}' subtree last, and since the goal is to balance the
	bipartition, we traverse first the subtree that assigns $u$ to the smallest
	side in the bipartition.

	As a footnote we will refer to the paper by et. al. (\cite{}) who show
	other branching strategies can be faster, and learn to predict the optimal
	strategy based matrix statistics.
	
	\subsubsection{Upper and lower bounds}

	\todo{Repeated runs with increasing bounds $0, 1, ...$.}
	\todo{Incremental computation of lower bound}


\end{document}
